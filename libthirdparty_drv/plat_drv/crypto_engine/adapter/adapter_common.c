/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Description: adapter common api
 * Author: s00294296
 * Create: 2020-03-31
 */
#include <adapter_common.h>
#include <common_sce.h>
#include <common_utils.h>
#include <pal_log.h>
#include <hisee_rsa.h>

#define BSP_THIS_MODULE                   BSP_MODULE_SEC

struct symm_algo_convert_table {
	u32 adapter_algo;
	u32 algo_type;
	u32 algo_mode;
};

struct asymm_algo_convert_table {
	u32 adapter_algo;
	u32 algo_type;
};

PRIVATE const struct symm_algo_convert_table g_symm_algo_table[] = {
	/* AES algorithm */
	{ CRYPTO_TYPE_AES_ECB_NOPAD, SYMM_ALGORITHM_AES, SYMM_MODE_ECB },
	{ CRYPTO_TYPE_AES_CBC_NOPAD, SYMM_ALGORITHM_AES, SYMM_MODE_CBC },
	{ CRYPTO_TYPE_AES_CTR, SYMM_ALGORITHM_AES, SYMM_MODE_CTR },
	{ CRYPTO_TYPE_AES_XTS, SYMM_ALGORITHM_AES, SYMM_MODE_XTS },
	{ CRYPTO_TYPE_AES_CMAC, SYMM_ALGORITHM_AES, SYMM_MODE_CMAC },
	{ CRYPTO_TYPE_AES_CBC_MAC_NOPAD, SYMM_ALGORITHM_AES, SYMM_MODE_CBCMAC },
	/* SM4 algorithm */
	{ CRYPTO_TYPE_SM4_ECB, SYMM_ALGORITHM_SM4, SYMM_MODE_ECB },
	{ CRYPTO_TYPE_SM4_CBC, SYMM_ALGORITHM_SM4, SYMM_MODE_CBC },
	{ CRYPTO_TYPE_SM4_CTR, SYMM_ALGORITHM_SM4, SYMM_MODE_CTR },
	{ CRYPTO_TYPE_SM4_XTS, SYMM_ALGORITHM_SM4, SYMM_MODE_XTS },
	/* DES algorithm */
	{ CRYPTO_TYPE_DES3_ECB_NOPAD, SYMM_ALGORITHM_DES, SYMM_MODE_ECB },
	{ CRYPTO_TYPE_DES3_CBC_NOPAD, SYMM_ALGORITHM_DES, SYMM_MODE_CBC },
	{ CRYPTO_TYPE_DES3_CBC_MAC_NOPAD, SYMM_ALGORITHM_DES, SYMM_MODE_CBCMAC },
	/* Hash algorithm */
	{ CRYPTO_TYPE_DIGEST_SHA1, ADAPTER_ALGO_HASH, SYMM_ALGORITHM_SHA1 },
	{ CRYPTO_TYPE_DIGEST_SHA224, ADAPTER_ALGO_HASH, SYMM_ALGORITHM_SHA224 },
	{ CRYPTO_TYPE_DIGEST_SHA256, ADAPTER_ALGO_HASH, SYMM_ALGORITHM_SHA256 },
	{ CRYPTO_TYPE_DIGEST_SHA384, ADAPTER_ALGO_HASH, SYMM_ALGORITHM_SHA384 },
	{ CRYPTO_TYPE_DIGEST_SHA512, ADAPTER_ALGO_HASH, SYMM_ALGORITHM_SHA512 },
	{ CRYPTO_TYPE_DIGEST_SM3, ADAPTER_ALGO_HASH, SYMM_ALGORITHM_SM3 },
	/* Hmac algorithm */
	{ CRYPTO_TYPE_HMAC_SHA1, ADAPTER_ALGO_HMAC, SYMM_ALGORITHM_SHA1 },
	{ CRYPTO_TYPE_HMAC_SHA224, ADAPTER_ALGO_HMAC, SYMM_ALGORITHM_SHA224 },
	{ CRYPTO_TYPE_HMAC_SHA256, ADAPTER_ALGO_HMAC, SYMM_ALGORITHM_SHA256 },
	{ CRYPTO_TYPE_HMAC_SHA384, ADAPTER_ALGO_HMAC, SYMM_ALGORITHM_SHA384 },
	{ CRYPTO_TYPE_HMAC_SHA512, ADAPTER_ALGO_HMAC, SYMM_ALGORITHM_SHA512 },
	{ CRYPTO_TYPE_HMAC_SM3, ADAPTER_ALGO_HMAC, SYMM_ALGORITHM_SM3 },
};

PRIVATE const struct asymm_algo_convert_table g_asymm_algo_table[] = {
	/* RSA crypto algorithm */
	{ CRYPTO_TYPE_RSAES_PKCS1_V1_5, HISEE_ALG_RSAES_PKCS1_V1_5 },
	{ CRYPTO_TYPE_RSAES_PKCS1_OAEP_MGF1_SHA1, HISEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 },
	{ CRYPTO_TYPE_RSAES_PKCS1_OAEP_MGF1_SHA224, HISEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 },
	{ CRYPTO_TYPE_RSAES_PKCS1_OAEP_MGF1_SHA256, HISEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 },
	{ CRYPTO_TYPE_RSAES_PKCS1_OAEP_MGF1_SHA384, HISEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 },
	{ CRYPTO_TYPE_RSAES_PKCS1_OAEP_MGF1_SHA512, HISEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 },
	{ CRYPTO_TYPE_RSA_NO_PAD, HISEE_ALG_RSA_NOPAD },
	/* RSA signature algorithm */
	{ CRYPTO_TYPE_RSASSA_PKCS1_V1_5_SHA1, HISEE_ALG_RSASSA_PKCS1_V1_5_SHA1 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_V1_5_SHA224, HISEE_ALG_RSASSA_PKCS1_V1_5_SHA224 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_V1_5_SHA256, HISEE_ALG_RSASSA_PKCS1_V1_5_SHA256 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_V1_5_SHA384, HISEE_ALG_RSASSA_PKCS1_V1_5_SHA384 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_V1_5_SHA512, HISEE_ALG_RSASSA_PKCS1_V1_5_SHA512 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_PSS_MGF1_SHA1, HISEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_PSS_MGF1_SHA224, HISEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_PSS_MGF1_SHA256, HISEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_PSS_MGF1_SHA384, HISEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 },
	{ CRYPTO_TYPE_RSASSA_PKCS1_PSS_MGF1_SHA512, HISEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 },
};

/* adapter symm algorithm type convert to hisee algorithm type */
err_bsp_t adapter_symm_algo_convert(uint32_t adapter_algo, u32 *palgo_type, u32 *palgo_mode)
{
	u32 i;

	for (i = 0; i < ARRAY_SIZE(g_symm_algo_table); i++) {
		if (g_symm_algo_table[i].adapter_algo == adapter_algo) {
			if (palgo_type)
				*palgo_type = g_symm_algo_table[i].algo_type;
			if (palgo_mode)
				*palgo_mode = g_symm_algo_table[i].algo_mode;
			return BSP_RET_OK;
		}
	}

	return ERR_API(ERRCODE_UNSUPPORT);
}

/* adapter asymm algorithm type convert to hisee algorithm type */
err_bsp_t adapter_asymm_algo_convert(uint32_t adapter_algo, u32 *palgo_type)
{
	u32 i;

	if (PAL_CHECK(!palgo_type))
		return ERR_API(ERRCODE_NULL);

	for (i = 0; i < ARRAY_SIZE(g_asymm_algo_table); i++) {
		if (g_asymm_algo_table[i].adapter_algo == adapter_algo) {
			*palgo_type = g_asymm_algo_table[i].algo_type;
			return BSP_RET_OK;
		}
	}

	return ERR_API(ERRCODE_UNSUPPORT);
}

