/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Description: implement GP API using mbedtls
 * Create: 2020-11-27
 */
#ifndef _AE_COMMON_H
#define _AE_COMMON_H

#include <mbedtls/cipher.h>
#include <mbedtls/cmac.h>

#define BYTE2BIT 8
struct aes_init_oper {
    uint32_t algorithm;
    uint32_t key_size;
    uint32_t mbedtls_alg;
};

static struct aes_init_oper g_aes_des_init_oeration[] = {
    { CRYPTO_TYPE_AES_ECB_NOPAD, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_ECB },
    { CRYPTO_TYPE_AES_ECB_NOPAD, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_ECB },
    { CRYPTO_TYPE_AES_ECB_NOPAD, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_ECB },
    { CRYPTO_TYPE_AES_CBC_NOPAD, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_CBC },
    { CRYPTO_TYPE_AES_CBC_NOPAD, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_CBC },
    { CRYPTO_TYPE_AES_CBC_NOPAD, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_CBC },
    { CRYPTO_TYPE_AES_CTR, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_CTR },
    { CRYPTO_TYPE_AES_CTR, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_CTR },
    { CRYPTO_TYPE_AES_CTR, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_CTR },
    { CRYPTO_TYPE_AES_CBC_MAC_NOPAD, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_CBC },
    { CRYPTO_TYPE_AES_CBC_MAC_NOPAD, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_CBC },
    { CRYPTO_TYPE_AES_CBC_MAC_NOPAD, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_CBC },
    { CRYPTO_TYPE_AES_CCM, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_CCM },
    { CRYPTO_TYPE_AES_CCM, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_CCM },
    { CRYPTO_TYPE_AES_CCM, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_CCM },
    { CRYPTO_TYPE_AES_GCM, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_GCM },
    { CRYPTO_TYPE_AES_GCM, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_GCM },
    { CRYPTO_TYPE_AES_GCM, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_GCM },
    { CRYPTO_TYPE_AES_XTS, AES_MAX_KEY_SIZE, MBEDTLS_CIPHER_AES_256_XTS },
    { CRYPTO_TYPE_AES_ECB_PKCS5, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_ECB },
    { CRYPTO_TYPE_AES_ECB_PKCS5, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_ECB },
    { CRYPTO_TYPE_AES_ECB_PKCS5, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_ECB },
    { CRYPTO_TYPE_AES_CBC_PKCS5, AES_TEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_128_CBC },
    { CRYPTO_TYPE_AES_CBC_PKCS5, AES_TWELVE_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_192_CBC },
    { CRYPTO_TYPE_AES_CBC_PKCS5, AES_FOURTEEN_ROUNDS_KEY_SIZE, MBEDTLS_CIPHER_AES_256_CBC },
    { CRYPTO_TYPE_DES_ECB_NOPAD, DES_KEY_SIZE, MBEDTLS_CIPHER_DES_ECB },
    { CRYPTO_TYPE_DES_CBC_NOPAD, DES_KEY_SIZE, MBEDTLS_CIPHER_DES_CBC },
    { CRYPTO_TYPE_DES3_ECB_NOPAD, DES3_KEY_SIZE, MBEDTLS_CIPHER_DES_EDE3_ECB },
    { CRYPTO_TYPE_DES3_CBC_NOPAD, DES3_KEY_SIZE, MBEDTLS_CIPHER_DES_EDE3_CBC },
};

static inline uint32_t get_mbedtls_ae_alg(uint32_t alg_type, uint32_t key_size)
{
    for (uint32_t i = 0; i < ARRAY_NUM(g_aes_des_init_oeration); i++) {
        if (g_aes_des_init_oeration[i].algorithm == alg_type &&
            g_aes_des_init_oeration[i].key_size == key_size)
            return g_aes_des_init_oeration[i].mbedtls_alg;
    }
    return 0;
}
#endif
