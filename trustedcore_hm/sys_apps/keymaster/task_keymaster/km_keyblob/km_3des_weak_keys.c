/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Description: keymaster 3des check weak key operation
 * Create: 2020-11-09
 */

#include "keymaster_defs.h"
#include "tee_crypto_api.h"
#include "km_common.h"
#include "km_types.h"
#include "keyblob.h"
static const keymaster_des_single_key_t g_des_weak_keys_table[] = {
    /* weak keys */
    { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } },
    { { 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE } },
    { { 0xE0, 0xE0, 0xE0, 0xE0, 0xF1, 0xF1, 0xF1, 0xF1 } },
    { { 0x1F, 0x1F, 0x1F, 0x1F, 0x0E, 0x0E, 0x0E, 0x0E } },
    /* semi-weak keys */
    { { 0x01, 0x1F, 0x01, 0x1F, 0x01, 0x0E, 0x01, 0x0E } },
    { { 0x1F, 0x01, 0x1F, 0x01, 0x0E, 0x01, 0x0E, 0x01 } },
    { { 0x01, 0xE0, 0x01, 0xE0, 0x01, 0xF1, 0x01, 0xF1 } },
    { { 0xE0, 0x01, 0xE0, 0x01, 0xF1, 0x01, 0xF1, 0x01 } },
    { { 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE } },
    { { 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01, 0xFE, 0x01 } },
    { { 0x1F, 0xE0, 0x1F, 0xE0, 0x0E, 0xF1, 0x0E, 0xF1 } },
    { { 0xE0, 0x1F, 0xE0, 0x1F, 0xF1, 0x0E, 0xF1, 0x0E } },
    { { 0x1F, 0xFE, 0x1F, 0xFE, 0x0E, 0xFE, 0x0E, 0xFE } },
    { { 0xFE, 0x1F, 0xFE, 0x1F, 0xFE, 0x0E, 0xFE, 0x0E } },
    { { 0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1, 0xFE } },
    { { 0xFE, 0xE0, 0xFE, 0xE0, 0xFE, 0xF1, 0xFE, 0xF1 } },
    /* possibly weak keys */
    { { 0x01, 0x01, 0x1F, 0x1F, 0x01, 0x01, 0x0E, 0x0E } },
    { { 0x1F, 0x1F, 0x01, 0x01, 0x0E, 0x0E, 0x01, 0x01 } },
    { { 0xE0, 0xE0, 0x1F, 0x1F, 0xF1, 0xF1, 0x0E, 0x0E } },
    { { 0x01, 0x01, 0xE0, 0xE0, 0x01, 0x01, 0xF1, 0xF1 } },
    { { 0x1F, 0x1F, 0xE0, 0xE0, 0x0E, 0x0E, 0xF1, 0xF1 } },
    { { 0xE0, 0xE0, 0xFE, 0xFE, 0xF1, 0xF1, 0xFE, 0xFE } },
    { { 0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE } },
    { { 0x1F, 0x1F, 0xFE, 0xFE, 0x0E, 0x0E, 0xFE, 0xFE } },
    { { 0xE0, 0xFE, 0x01, 0x1F, 0xF1, 0xFE, 0x01, 0x0E } },
    { { 0x01, 0x1F, 0x1F, 0x01, 0x01, 0x0E, 0x0E, 0x01 } },
    { { 0x1F, 0xE0, 0x01, 0xFE, 0x0E, 0xF1, 0x01, 0xFE } },
    { { 0xE0, 0xFE, 0x1F, 0x01, 0xF1, 0xFE, 0x0E, 0x01 } },
    { { 0x01, 0x1F, 0xE0, 0xFE, 0x01, 0x0E, 0xF1, 0xFE } },
    { { 0x1F, 0xE0, 0xE0, 0x1F, 0x0E, 0xF1, 0xF1, 0x0E } },
    { { 0xE0, 0xFE, 0xFE, 0xE0, 0xF1, 0xFE, 0xFE, 0xF1 } },
    { { 0x01, 0x1F, 0xFE, 0xE0, 0x01, 0x0E, 0xFE, 0xF1 } },
    { { 0x1F, 0xE0, 0xFE, 0x01, 0x0E, 0xF1, 0xFE, 0x01 } },
    { { 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE } },
    { { 0x01, 0xE0, 0x1F, 0xFE, 0x01, 0xF1, 0x0E, 0xFE } },
    { { 0x1F, 0xFE, 0x01, 0xE0, 0x0E, 0xFE, 0x01, 0xF1 } },
    { { 0xFE, 0x01, 0x1F, 0xE0, 0xFE, 0x01, 0x0E, 0xF1 } },
    { { 0xFE, 0x01, 0xE0, 0x1F, 0xFE, 0x01, 0xF1, 0x0E } },
    { { 0x1F, 0xFE, 0xE0, 0x01, 0x0E, 0xFE, 0xF1, 0x01 } },
    { { 0xFE, 0x1F, 0x01, 0xE0, 0xFE, 0x0E, 0x01, 0xF1 } },
    { { 0x01, 0xE0, 0xE0, 0x01, 0x01, 0xF1, 0xF1, 0x01 } },
    { { 0x1F, 0xFE, 0xFE, 0x1F, 0x0E, 0xFE, 0xFE, 0x0E } },
    { { 0xFE, 0x1F, 0xE0, 0x01, 0xFE, 0x0E, 0xF1, 0x01 } },
    { { 0x01, 0xE0, 0xFE, 0x1F, 0x01, 0xF1, 0xFE, 0x0E } },
    { { 0xE0, 0x01, 0x01, 0xE0, 0xF1, 0x01, 0x01, 0xF1 } },
    { { 0xFE, 0x1F, 0x1F, 0xFE, 0xFE, 0x0E, 0x0E, 0xFE } },
    { { 0x01, 0xFE, 0x1F, 0xE0, 0x01, 0xFE, 0x0E, 0xF1 } },
    { { 0xE0, 0x01, 0x1F, 0xFE, 0xF1, 0x01, 0x0E, 0xFE } },
    { { 0xFE, 0xE0, 0x01, 0x1F, 0xFE, 0xF1, 0x01, 0x0E } },
    { { 0x01, 0xFE, 0xE0, 0x1F, 0x01, 0xFE, 0xF1, 0x0E } },
    { { 0xE0, 0x01, 0xFE, 0x1F, 0xF1, 0x01, 0xFE, 0x0E } },
    { { 0xFE, 0xE0, 0x1F, 0x01, 0xFE, 0xF1, 0x0E, 0x01 } },
    { { 0x01, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01 } },
    { { 0xE0, 0x1F, 0x01, 0xFE, 0xF1, 0x0E, 0x01, 0xFE } },
    { { 0xFE, 0xE0, 0xE0, 0xFE, 0xFE, 0xF1, 0xF1, 0xFE } },
    { { 0x1F, 0x01, 0x01, 0x1F, 0x0E, 0x01, 0x01, 0x0E } },
    { { 0xE0, 0x1F, 0x1F, 0xE0, 0xF1, 0x0E, 0x0E, 0xF1 } },
    { { 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x01, 0x01 } },
    { { 0x1F, 0x01, 0xE0, 0xFE, 0x0E, 0x01, 0xF1, 0xFE } },
    { { 0xE0, 0x1F, 0xFE, 0x01, 0xF1, 0x0E, 0xFE, 0x01 } },
    { { 0xFE, 0xFE, 0x1F, 0x1F, 0xFE, 0xFE, 0x0E, 0x0E } },
    { { 0x1F, 0x01, 0xFE, 0xE0, 0x0E, 0x01, 0xFE, 0xF1 } },
    { { 0xE0, 0xE0, 0x01, 0x01, 0xF1, 0xF1, 0x01, 0x01 } },
    { { 0xFE, 0xFE, 0xE0, 0xE0, 0xFE, 0xFE, 0xF1, 0xF1 } },
};

int32_t check_des_weak_keys(const uint8_t *key, uint32_t key_size)
{
    uint32_t i;
    uint32_t weak_keys_count = sizeof(g_des_weak_keys_table) / sizeof(keymaster_des_single_key_t);
    bool condition = (check_symmetric_key_random(key_size, key) != 0 || key_size != KM_3DES_KEY_SIZE);
    if (condition) {
        tloge("weak key\n");
        return -1;
    }
    const uint8_t *key2 = key + DES_ONE_KEY_LEN;
    const uint8_t *key3 = key2 + DES_ONE_KEY_LEN;
    condition = (TEE_MemCompare(key, key2, DES_ONE_KEY_LEN) == 0 || TEE_MemCompare(key, key3, DES_ONE_KEY_LEN) == 0 ||
        TEE_MemCompare(key2, key3, DES_ONE_KEY_LEN) == 0);
    if (condition) {
        tloge("same key, need repeat random");
        return 1;
    }
    for (i = 0; i < weak_keys_count; ++i) {
        condition = (TEE_MemCompare(g_des_weak_keys_table[i].key, key, DES_ONE_KEY_LEN) == 0 ||
            TEE_MemCompare(g_des_weak_keys_table[i].key, key2, DES_ONE_KEY_LEN) == 0 ||
            TEE_MemCompare(g_des_weak_keys_table[i].key, key3, DES_ONE_KEY_LEN) == 0);
        if (condition) {
            tloge("weak key, need repeat random");
            return 1;
        }
    }
    return 0;
}
