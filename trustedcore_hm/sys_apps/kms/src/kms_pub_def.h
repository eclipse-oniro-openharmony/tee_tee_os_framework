/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Description: public struct or define
 * Author: wangwenyuan.wang@huawei.com
 * Create: 2020-04-14
 */
#ifndef KMS_KMS_PUB_DEF_H
#define KMS_KMS_PUB_DEF_H
#include <string.h>
#include "tee_internal_api.h"

#define KEY_TAG_TYPE_MOVE_BITS 28
#define KMS_TAG_TLV_TYPE 0XFFFF9999
#define MAX_TAG_NUMBER 15
#define INVALID_VALUE 0xFFFFFFFF
#define MAX_HASH_LEN 64
#define BYTE_TO_BIT 8
#define HASH_TYPE_MOVE 4
#define KEY_BLOB_MAC_LEN 32
#define FIX_IV_LEN 16
#define DELETE_KEY_TAG_COUNT 1
#define MAX_RSA_KEY_SIZE_BYTE        512
#define CONST_RSA_PUB_E_SIZE_BYTE    3
/* MAX_KEY_ID_LEN should never larger than sizeof(struct kms_key_base_info) */
#define MAX_KEY_ID_LEN 65
#define KMS_KEY_VERSION_1 20200506
#define KMS_KEY_VERSION_2 2
#define KEY_BLOB_MAX_SIZE    0x1000
#define BUFFER_DATA_MAX_SIZE    0x1000
#define MAGIC   0x484B4D53    /* HKMS */
struct kms_buffer_data {
    uint32_t length;
    uint8_t *buffer;
};

struct kms_offset_t {
    uint32_t data_len;
    uint32_t data_offset;
};

struct kms_param_t {
    uint32_t tag;
    union {
        uint32_t enumerated;
        bool boolean;
        uint32_t integer;
        uint64_t long_integer;
        uint64_t date_time;
        struct kms_offset_t blob;
    } data;
};

struct kms_param_set_t {
    uint32_t param_count;
    struct kms_param_t params[0];
};

enum kms_key_type {
    KMS_KEY_TYPE_RSA = 0x10101,
    KMS_KEY_TYPE_RSA_PUBLIC = 0x10103,
    KMS_KEY_TYPE_ECDSA = 0x10201,
    KMS_KEY_TYPE_ECDSA_PUBLIC = 0x10202,
    KMS_KEY_TYPE_ECDH = 0x10301,
    KMS_KEY_TYPE_ECDH_PUBLIC = 0x10302,
    KMS_KEY_TYPE_AES = 0x10401,
    KMS_KEY_TYPE_3DES = 0x10501,
    KMS_KEY_TYPE_HMAC_SHA256 = 0x10601,
    KMS_KEY_TYPE_HMAC = KMS_KEY_TYPE_HMAC_SHA256,
    KMS_KEY_TYPE_HMAC_SHA384 = 0x10602,
    KMS_KEY_TYPE_HMAC_SHA512 = 0x10603,
    KMS_KEY_TYPE_ED25519 = 0x10701,
    KMS_KEY_TYPE_ED25519_PUBLIC = 0x10702,
    KMS_KEY_TYPE_X25519 = 0x10801,
    KMS_KEY_TYPE_X25519_PUBLIC = 0x10802,
    KMS_KEY_TYPE_SM2 = 0x10901,
    KMS_KEY_TYPE_SM2_PUBLIC = 0x10902,
    KMS_KEY_TYPE_SM4 = 0x10a01,
    KMS_KEY_TYPE_SIP_HASH = 0x10b01,
    KMS_KEY_TYPE_GENERIC = 0x10c01,
};

enum kms_key_algorithm {
    KMS_ALG_AES_ECB = 0x20001,
    KMS_ALG_AES_CBC = 0x20002,
    KMS_ALG_AES_CTR = 0x20003,
    /*
     * Please use KMS_ALG_AES_GCM_V2 instead.  This implementation is not standard.
     * 'KMS_ALG_AES_GCM' is a deprecated alg type. Ciphertext generated by 'KMS_ALG_AES_GCM' has
     * 4 more bytes than 'KMS_ALG_AES_GCM_V2' at the end.
     */
    KMS_ALG_AES_GCM = 0x20004,
    KMS_ALG_AES_CCM = 0x20005,
    KMS_ALG_AES_CTS = 0x20006,
    KMS_ALG_AES_CMAC = 0x20007,
    KMS_ALG_AES_GCM_V2 = 0x20008,
    KMS_ALG_ED25519 = 0x2000a,
    KMS_ALG_X25519 = 0x2000b,
    KMS_ALG_ECDSA = 0x2000c,
    KMS_ALG_RSA = 0x2000d,
    KMS_ALG_MD5 = 0x20021,
    KMS_ALG_SHA1 = 0x20022,
    KMS_ALG_SHA224 = 0x20023,
    KMS_ALG_SHA256 = 0x20024,
    KMS_ALG_SHA384 = 0x20025,
    KMS_ALG_SHA512 = 0x20026,
    KMS_ALG_MAC = 0x20027,
    KMS_ALG_SIP_HASH = 0x20028,
    KMS_ALG_SM2_DSA_SM3 = 0x20030,
    KMS_ALG_SM2_KEP = 0x20031,
    KMS_ALG_SM2_PKE = 0x20032,
    KMS_ALG_SM3 = 0x20033,
    KMS_ALG_SM4_ECB = 0x20034,
    KMS_ALG_SM4_CBC = 0x20035,
    KMS_ALG_SM4_CTR = 0x20036,
    KMS_ALG_SM4_OFB = 0x20037,
    KMS_ALG_SM4_XTS = 0x20038,
    KMS_ALG_SM4_GCM = 0x20039,
};

enum kms_padding {
    KMS_PAD_NONE = 1,
    KMS_PAD_RSA_OAEP = 2,
    KMS_PAD_RSA_PSS_SIGN = 3,
    KMS_PAD_RSA_PKCS1_SIGN = 4,
    KMS_PAD_PKCS5 = 5,
    /* PKCS7 could support different block sizes. It is the same as PKCS5 while implemented with 16-byte-block */
    KMS_PAD_PKCS7 = 5,
};

enum kms_block_mode {
    KMS_MODE_ECB = 0x40001,
    KMS_MODE_CBC = 0x40002,
    KMS_MODE_CTR = 0x40003,
    KMS_MODE_GCM = 0x40005,
};

enum kms_tag_type {
    KMS_INVALID = 0 << KEY_TAG_TYPE_MOVE_BITS, /* Invalid type, used to designate a tag as uninitialized */
    KMS_INTEGER = 1 << KEY_TAG_TYPE_MOVE_BITS,
    KMS_BYTES = 2 << KEY_TAG_TYPE_MOVE_BITS,
    KMS_INTEGER_REP = 3 << KEY_TAG_TYPE_MOVE_BITS, /* Repeatable integer value */
    KMS_BOOL = 4 << KEY_TAG_TYPE_MOVE_BITS,
    KMS_DATE = 5 << KEY_TAG_TYPE_MOVE_BITS,
    KMS_BYTES_REP = 6 << KEY_TAG_TYPE_MOVE_BITS, /* Repeatable bytes blob */
};

enum kms_tags {
    KMS_TAG_INVALID = KMS_INVALID | 0,
    KMS_TAG_KEY_TYPE = KMS_INTEGER | 1,
    KMS_TAG_KEY_SIZE = KMS_INTEGER | 2,
    KMS_TAG_OPERATION_ALGORITHM = KMS_INTEGER | 3,
    KMS_TAG_TA_DATA = KMS_INTEGER | 4,
    KMS_TAG_EC_CURVE = KMS_INTEGER | 5,
    KMS_TAG_PADDING = KMS_INTEGER | 6,
    KMS_TAG_RSA_PUBLIC_EXPONENT = KMS_BYTES | 7,
    KMS_TAG_HASH_TYPE = KMS_INTEGER | 8,
    KMS_TAG_HUK = KMS_BYTES | 9,
    KMS_TAG_SALT_VALUE = KMS_BYTES | 10,
    /* IV value for symetric encrypto/decrypto */
    KMS_TAG_IV = KMS_BYTES | 11,
    /* application specification data, must contained everywhere if generated/imported with the data */
    KMS_TAG_APP_ID = KMS_BYTES | 12,
    /* AES GCM MAC len, proper values: [96,104,112,120,128] */
    KMS_TAG_GCM_MAC_LEN = KMS_INTEGER | 13,
    KMS_TAG_ITER_NUM = KMS_INTEGER | 14, /* UNIMPLEMENT NOW!!! */
    /* AES GCM AAD data should not appear after input data transfered in */
    KMS_TAG_GCM_AAD = KMS_BYTES | 15,
    /* key material type */
    KMS_TAG_OBJ_TYPE = KMS_INTEGER | 16,
    KMS_TAG_KEY_ID = KMS_INTEGER | 17,
    KMS_TAG_KEY_CTR = KMS_INTEGER | 18,
    KMS_TAG_KEY_FLAGS = KMS_INTEGER | 19,
    /* UNIMPLEMENT NOW!!!  only the symmetric key with this tag and value true, plaintext is exportable */
    KMS_TAG_CLRTEXT_EXPORTABLE = KMS_BOOL | 20,
    /* only key with this tag and value true could be derivable */
    KMS_TAG_DERIVABLE = KMS_BOOL | 21,
    /*
     * A volatile key is not persistented store and kept in memory for a while.
     * The caller should set this tag with value true while using. The caller should destory it after using.
     * It could be used for key generating, importing, deriving process. The tag is related to the new generated key.
     */
    KMS_TAG_VOLATILE_KEY = KMS_BOOL | 22,
    /* Used for a key originated DERIVATED */
    KMS_TAG_PARENT_KEY_ID = KMS_BYTES | 23,
    /* tag value [30~39] reserved for internal TAG, this tag is set and verified by KMS, caller setting is invalid */
    KMS_TAG_CREATE_TIME = KMS_DATE | 30, /* UNIMPLEMENT NOW!!! Internal TAG */
    KMS_TAG_ORIGIN = KMS_INTEGER | 31, /* UNIMPLEMENT NOW!!! Internal TAG */

    /* key derivation function type should be a proper value as defined in enum kms_kdf_type whith proper params */
    KMS_TAG_KDF_TYPE = KMS_INTEGER | 41,
    /*
     * Sometimes there are a batch of keys imported and commited. To keep these keys are all successfully imported or
     * all failed, the caller could use KMS_TAG_BATCH_NUM to indicate that if a key in this batch is failed to import
     * should rollback all the keys. It could be added while import a key one by one, and then commit the batch of
     * key list.
     * Notice: This tag only use in a single session / thread. session context should restrict session count.
     */
    KMS_TAG_BATCH_NUM = KMS_INTEGER | 42,
    /*
     * Sometimes there are a batch of keys imported waited to commit. The commit operation will
     * handle the keys submit as a whole status, all commited or all rollback. The KMS_TAG_BATCH_KEY_ID is a repeatable
     * TAG which reference the element of the batch. All keyids with the same BATCH_NUM should be exactly the same as
     * the import operation.
     * Notice: This tag only use in a single session / thread. session context should restrict session count.
     */
    KMS_TAG_BATCH_KEY_ID_IN_LIST = KMS_BYTES_REP | 43,
    /* Used as label for KDF */
    KMS_TAG_KDF_LABEL = KMS_BYTES | 44,
    /* Used as context for KDF */
    KMS_TAG_KDF_CONTEXT = KMS_BYTES | 45,
    /*
     * UNIMPLEMENT NOW!!! Use for kdf operation, if this tag specified with value true, the destination key id will
     * add a random string
     * suffix after the input key id.
     */
    KMS_TAG_KEY_ID_RANDOM_SUFFIX = KMS_BOOL | 46,
    /* current process name */
    KMS_TAG_APP_PROC_NAME = KMS_BYTES | 47,
    /* the processes name who can export key */
    KMS_TAG_EXPORT_PROC_NAME = KMS_BYTES_REP | 48,
    /* the processes name who can delete key */
    KMS_TAG_DELETE_PROC_NAME = KMS_BYTES_REP | 49,
    /* the format of key when import/export */
    KMS_TAG_KEY_FORMAT = KMS_INTEGER | 50,

    KMS_TAG_TASK_ID = KMS_INTEGER | 100,
    KMS_TAG_VIN = KMS_BYTES | 101,
    KMS_TAG_ECU_CTR = KMS_INTEGER | 102,
    /* The above tage values are defined by KMS, tag with value only larger than 9000 could be added */
    KMS_TAG_BUFF_SIZE = KMS_INTEGER | 9000,
};

enum kms_mode {
    KMS_MODE_ENCRYPT = 0x0,
    KMS_MODE_DECRYPT,
    KMS_MODE_SIGN,
    KMS_MODE_VERIFY,
    KMS_MODE_MAC,
    KMS_MODE_DIGEST,
    KMS_MODE_DERIVE,
};

enum kms_hash_type {
    KMS_HASH_MD5 = 1,
    KMS_HASH_SHA1,
    KMS_HASH_SHA224,
    KMS_HASH_SHA256,
    KMS_HASH_SHA384,
    KMS_HASH_SHA512,
    KMS_HASH_SM3,
};

enum kms_kdf_type {
    KMS_KDF_NONE = 0,     /* Do not use a key derivation function; use the raw key */
    /*
     * UNIMPLEMENT NOW!!!
     * For (i = to Ceiling[L/h])
     *    K(i) = PRF(Ki, [i]_2 || Label || 0x00 || Context || [L]_2),
     *    result(i)= result(i-1) || K(i)
     * Return Ko = leftmost L bits of result(n)
     */
    KMS_KDF_NIST800_108_CTR = 1, /* unimplement */
    /* output = Aes_ecb(ki, (label || 0x00 || context)) */
    KMS_KDF_CTR_DRBG_AES_ECB = 2, /* required params: base key id, label, context, dest key id */
    /*
     * insert ki before counter 'i' like NIST800_108, set SHA256 as a PRF
     * For (i = to Ceiling[L/h])
     *    K(i) = SHA256(Ki || [i]_2 || Label || 0x00 || Context || [L]_2),
     *    result(i)= result(i-1) || K(i)
     * Return Ko = leftmost L/8 bytes of result(n)
     */
    KMS_KDF_AUDI_CTR_LIKE_NIST800_108 = 21,
};

enum kms_origin {
    /* indicate a key generate type, take 4 bits */
    KMS_ORIGIN_NONE = 0x0,
    KMS_ORIGIN_CREATE = 0x01,
    KMS_ORIGIN_IMPORT = 0x02,
    KMS_ORIGIN_DERIVATED = 0x03,
    KMS_ORIGIN_MAX = 0x0f,
};

enum KmsGenKeyType {
    /* Generate a key without special method */
    KMS_KG_NONE = 0,
    KMS_KG_FIPS186_4_ECC_USING_EX_RANDOM_BITS = 1,
};

enum key_format {
    KMS_KEY_FORMAT_RAW = 0,      /* for symmetric key import */
    KMS_KEY_FORMAT_PKCS1 = 1,    /* for rsa private key import */
    KMS_KEY_FORMAT_PKCS8 = 2,    /* for asymmetric key import, unimplement */
    KMS_KEY_FORMAT_X509 = 3,     /* for public key export, unimplement */
};

struct uint_to_uint {
    uint32_t src;
    uint32_t dest;
};

struct three_uint {
    uint32_t u1;
    uint32_t u2;
    uint32_t u3;
};

enum key_engine_type {
    ENGINE_TYPE_GP = 1,
    ENGINE_TYPE_HSM,
};

enum kms_error_code {
    KMS_ERROR_OK = 0,
    KMS_ERROR_UNIMPLEMENTED = -1,
    KMS_ERROR_UNSUPPORTED_MODE = -2,
    KMS_ERROR_INCOMPATIBLE_MODE = -3,
    KMS_ERROR_UNSUPPORTED_ALGORITHM = -4,
    KMS_ERROR_INCOMPATIBLE_ALGORITHM = -5,
    KMS_ERROR_UNSUPPORTED_KEY_SIZE = -6,
    KMS_ERROR_UNSUPPORTED_BLOCK_MODE = -7,
    KMS_ERROR_INCOMPATIBLE_BLOCK_MODE = -8,
    KMS_ERROR_UNSUPPORTED_MAC_LENGTH = -9,
    KMS_ERROR_UNSUPPORTED_PADDING_MODE = -10,
    KMS_ERROR_INCOMPATIBLE_PADDING_MODE = -11,
    KMS_ERROR_UNSUPPORTED_DIGEST = -12,
    KMS_ERROR_INCOMPATIBLE_DIGEST = -13,
    KMS_ERROR_INVALID_EXPIRATION_TIME = -14,
    KMS_ERROR_INVALID_APP_ID = -15,
    KMS_ERROR_UNSUPPORTED_KEY_FORMAT = -16,
    KMS_ERROR_INCOMPATIBLE_KEY_FORMAT = -17,
    KMS_ERROR_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM = -18,
    KMS_ERROR_UNSUPPORTED_KEY_VERIFICATION_ALGORITHM = -19,
    KMS_ERROR_INVALID_INPUT_LENGTH = -20,
    KMS_ERROR_KEY_EXPORT_OPTIONS_INVALID = -21,
    KMS_ERROR_KEY_NOT_YET_VALID = -22,
    KMS_ERROR_KEY_EXPIRED = -23,
    KMS_ERROR_OUTPUT_PARAMETER_NULL = -24,
    KMS_ERROR_INVALID_OPERATION_HANDLE = -25,
    KMS_ERROR_VERIFICATION_FAILED = -26,
    KMS_ERROR_TOO_MANY_OPERATIONS = -27,
    KMS_ERROR_INVALID_KEY_BLOB = -28,
    KMS_ERROR_INVALID_ARGUMENT = -29,
    KMS_ERROR_UNSUPPORTED_TAG = -30,
    KMS_ERROR_INVALID_TAG = -31,
    KMS_ERROR_MEMORY_ALLOCATION_FAILED = -32,
    KMS_ERROR_IMPORT_PARAMETER_MISMATCH = -33,
    KMS_ERROR_OPERATION_CANCELLED = -34,
    KMS_ERROR_CONCURRENT_ACCESS_CONFLICT = -35,
    KMS_ERROR_UNSUPPORTED_EC_FIELD = -36,
    KMS_ERROR_MISSING_NONCE = -37,
    KMS_ERROR_INVALID_NONCE = -38,
    KMS_ERROR_MISSING_MAC_LENGTH = -39,
    KMS_ERROR_KEY_RATE_LIMIT_EXCEEDED = -40,
    KMS_ERROR_CALLER_NONCE_PROHIBITED = -41,
    KMS_ERROR_KEY_MAX_OPS_EXCEEDED = -42,
    KMS_ERROR_INVALID_MAC_LENGTH = -43,
    KMS_ERROR_MISSING_MIN_MAC_LENGTH = -44,
    KMS_ERROR_UNSUPPORTED_MIN_MAC_LENGTH = -45,
    KMS_ERROR_UNSUPPORTED_KDF = -46,
    KMS_ERROR_UNSUPPORTED_EC_CURVE = -47,
    KMS_ERROR_KEY_REQUIRES_UPGRADE = -48,
    KMS_ERROR_NOT_CONFIGURED = -49,
    KMS_ERROR_PARAM_CHECK_FAILED = -50,

    /* Audi definition may be extended between -300 ~ -200 */
    KMS_ERROR_GENERIC = -201, /* general error */
    KMS_ERROR_NULL_POINTER = -212, /* null pointer */
    KMS_ERROR_KEY_ID_NOT_PRESENT = -220, /* The key with ID was not included in the last provisioning */
    KMS_ERROR_KEY_NOT_CLEARTEXT_EXPORTABLE = -221, /* The key with this ID cannot be read in cleartext */
    KMS_ERROR_KEY_CORRUPTED = -222, /* Corrupted key material was detected when checking the verification checksum */
    KMS_ERROR_BUSY = -223, /* Function not available, some task is proccessing */
    KMS_ERROR_PRECONDITION_NOT_MET = -224, /* The prerequisites for running this function are not being met */
    KMS_ERROR_SHORT_BUFFER = -225, /* The passed buffer was too small to store the requested data */
    /* The key flags conflict with each other */
    KMS_ERROR_CONFLICT_FLAGS = -237,
    /* The request key has the ABSTRACT_KEY flag and the function is not available for keys with this flag */
    KMS_ERROR_NOT_AVAILABLE_FOR_ABSTRACT_KEY = -238,
    /* The configured size for storing metadata, certificates, or application-specific data is too small */
    KMS_ERROR_CONFIG_STORAGE_SIZE_TOO_SMALL = -240,
    /* A key ID that has not been configured */
    KMS_ERROR_KEY_ID_NOT_CONFIGURED = -242,
    /* Error while attempting to read a key in the secure hardware environment key store */
    KMS_ERROR_KEY_READ_FAIL = -245,
    /* Error while attempting to write to a key in the secure hardware environment key store */
    KMS_ERROR_KEY_WRITE_FAIL = 246,
    /* Error when attempting to write a key in the secure hardware environment key store: Wrong key length */
    KMS_ERROR_KEY_SIZE_WRITE_WRONG_LENGTH = -247,
    /* Other error when attempting to access the secure hardware environment key store or cryptographic library. */
    KMS_ERROR_OTHER = -248,

    /* Additional error codes may be extented after -1000 to avoid code collision */
    KMS_ERROR_UNKNOWN_ERROR = -1000,
};

#define KEY_BASE_INFO_RESERVE_NUMBER 3
struct kms_key_base_info {
    uint8_t mac[KEY_BLOB_MAC_LEN];
    uint32_t key_type;
    uint32_t key_size;
    uint32_t version;
    enum key_engine_type eng_type;
    uint32_t magic;
    uint8_t iv[FIX_IV_LEN];
    uint16_t gp_key_offset;
    uint16_t gp_key_length;
    uint16_t params_offset;
    uint16_t params_length;
    uint16_t params_blob_offset;
    uint16_t params_blob_length;
    uint16_t reserve[KEY_BASE_INFO_RESERVE_NUMBER];
    uint16_t total_length;
    uint8_t keyblob_body[0];
};
#define array_size(array) (sizeof(array) / sizeof(array[0]))
static inline uint32_t kms_tag_get_type(uint32_t tag)
{
    return (tag & (0xF << KEY_TAG_TYPE_MOVE_BITS));
}
void mem_print(const char *head, const uint8_t *buf, uint32_t len);
#endif
